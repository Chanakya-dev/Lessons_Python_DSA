# Data Structures and Algorithms Problem Set

## 1. Strings

### Basic:
1. Write a program to reverse a string.
2. Write a program to check if a string is a palindrome.
3. Write a program to count the occurrence of a character in a string.
4. Write a program to find the first non-repeating character in a string.
5. Write a program to check if two strings are anagrams of each other.

### Intermediate:
1. Write a program to perform string compression.
2. Find the longest common prefix in a list of strings.
3. Write a program to check if a string contains all unique characters.
4. Write a program to replace all spaces in a string with `%20`.
5. Write a program to find the length of the longest substring without repeating characters.

### Advanced:
1. Write a program to implement regular expression matching.
2. Implement a program to check if a string is a rotation of another string.
3. Find the longest palindromic substring in a string.
4. Implement a program for string matching using the Knuth-Morris-Pratt (KMP) algorithm.
5. Write a program to implement the Rabin-Karp algorithm for string matching.

---

## 2. Arrays

### Basic:
1. Write a program to find the largest element in an array.
2. Reverse an array in place.
3. Find the sum of all elements in an array.
4. Write a program to check if an array is sorted.
5. Count the occurrences of a given element in an array.

### Intermediate:
1. Given an array, find the two numbers that add up to a given target sum.
2. Rotate an array by `k` positions.
3. Write a program to find the missing number in a sorted array of `n-1` numbers.
4. Remove duplicates from a sorted array.
5. Find the first non-repeating element in an array.

### Advanced:
1. Find the contiguous subarray with the maximum sum (Kadane’s Algorithm).
2. Given an array, implement binary search to find an element.
3. Find the intersection of two arrays.
4. Find the longest subsequence of consecutive numbers in an unsorted array.
5. Implement a program to find the majority element in an array.

---

## 3. Linked List

### Basic:
1. Reverse a singly linked list.
2. Detect if a linked list has a cycle.
3. Find the middle element of a linked list.
4. Delete a node from a linked list.
5. Print all elements of a linked list.

### Intermediate:
1. Merge two sorted linked lists into one sorted linked list.
2. Remove the nth node from the end of a linked list.
3. Find the intersection point of two linked lists.
4. Implement a function to check if a linked list is palindrome.
5. Sort a linked list using merge sort.

### Advanced:
1. Flatten a multi-level doubly linked list.
2. Add two numbers represented by linked lists.
3. Implement a function to detect the start of a cycle in a linked list.
4. Reverse a portion of a linked list between `m` and `n`.
5. Merge `k` sorted linked lists.

---

## 4. Stacks and Queues

### Basic:
1. Implement a stack using an array.
2. Implement a queue using two stacks.
3. Write a program to evaluate a postfix expression.
4. Check for balanced parentheses in an expression.
5. Implement a circular queue.

### Intermediate:
1. Implement a stack with constant time retrieval of the minimum element.
2. Design a stack that supports `push`, `pop`, `top`, and `getMin` operations in constant time.
3. Implement a priority queue using a heap.
4. Implement a queue using a singly linked list.
5. Implement a stack using two queues.

### Advanced:
1. Design a stack that supports push, pop, and retrieval of the maximum element in constant time.
2. Implement a deque (double-ended queue) from scratch.
3. Implement a sliding window maximum using a deque.
4. Write a program to sort a stack using another stack.
5. Design a data structure that supports insert, delete, and get the median element in constant time.

---

## 5. Trees

### Basic:
1. Find the height of a binary tree.
2. Perform an inorder traversal of a binary tree.
3. Write a program to check if a binary tree is balanced.
4. Find the maximum element in a binary tree.
5. Count the number of leaf nodes in a binary tree.

### Intermediate:
1. Perform a level-order traversal (BFS) of a binary tree.
2. Find the lowest common ancestor of two nodes in a binary tree.
3. Implement preorder and postorder traversal of a binary tree.
4. Write a program to check if a binary tree is a binary search tree (BST).
5. Given a binary tree, write a program to convert it into its mirror image.

### Advanced:
1. Find the diameter of a binary tree.
2. Implement a program to find the kth smallest element in a binary search tree (BST).
3. Write a program to flatten a binary tree to a linked list.
4. Perform a depth-first search (DFS) traversal for a binary tree.
5. Write a program to check if a binary tree is a complete binary tree.

---

## 6. Graphs

### Basic:
1. Implement Depth-First Search (DFS) for a graph.
2. Implement Breadth-First Search (BFS) for a graph.
3. Write a program to find the degree of a node in a graph.
4. Write a program to find the shortest path in an unweighted graph (BFS).
5. Implement a graph traversal using DFS for a directed graph.

### Intermediate:
1. Detect a cycle in an undirected graph using DFS.
2. Implement Dijkstra’s algorithm to find the shortest path in a weighted graph.
3. Find strongly connected components (SCC) in a directed graph using Kosaraju’s algorithm.
4. Find the topological sort of a directed acyclic graph (DAG).
5. Write a program to check if a graph is bipartite.

### Advanced:
1. Implement the Bellman-Ford algorithm for shortest paths in a graph with negative weights.
2. Implement Kruskal’s algorithm for finding the Minimum Spanning Tree (MST).
3. Write a program to detect negative cycles in a graph using the Bellman-Ford algorithm.
4. Implement Floyd-Warshall algorithm for finding the shortest paths between all pairs of vertices.
5. Write a program to solve the traveling salesman problem using dynamic programming.

---

## 7. Hashing

### Basic:
1. Implement a hash map (hash table) from scratch.
2. Count the frequency of elements in an array using a hash map.
3. Find the first non-repeating character in a string using a hash map.
4. Find the intersection of two arrays using hash sets.
5. Write a program to check if two strings are anagrams using a hash map.

### Intermediate:
1. Group anagrams from a list of strings using a hash map.
2. Find the longest subarray with sum 0 using a hash map.
3. Check if two arrays have the same elements using a hash map.
4. Find the longest consecutive subsequence in an unsorted array using a hash set.
5. Solve the problem of finding the number of subarrays with a given sum using a hash map.

### Advanced:
1. Solve the problem of finding the duplicate number in an array using a hash set.
2. Find all pairs in an array whose sum is divisible by `k` using a hash map.
3. Write a program to check if a pair with a given sum exists in an unsorted array.
4. Find the subarrays that sum to a given target using a hash map.
5. Solve the problem of finding the longest substring without repeating characters using a hash set.

---

## 8. Algorithms

### Sorting Algorithms:
1. Implement the bubble sort algorithm.
2. Implement the insertion sort algorithm.
3. Implement the merge sort algorithm.
4. Implement the quicksort algorithm.
5. Implement the heap sort algorithm.

### Searching Algorithms:
1. Implement the binary search algorithm.
2. Write an algorithm to find the first occurrence of an element in a sorted array.
3. Write an algorithm to find the last occurrence of an element in a sorted array.
4. Implement an algorithm to perform a linear search in an unsorted array.
5. Implement an algorithm to search for an element in a rotated sorted array.

### Dynamic Programming:
1. Solve the Fibonacci sequence using dynamic programming.
2. Implement the 0/1 knapsack problem using dynamic programming.
3. Find the longest common subsequence (LCS) of two strings.
4. Solve the matrix chain multiplication problem using dynamic programming.
5. Implement the coin change problem using dynamic programming.

### Greedy Algorithms:
1. Solve the activity selection problem using a greedy approach.
2. Implement the fractional knapsack problem using a greedy approach.
3. Solve the job sequencing problem using a greedy approach.
4. Find the minimum number of coins required to make change using a greedy approach.
5. Solve the Huffman coding problem using a greedy approach.

### Backtracking Algorithms:
1. Solve the N-Queens problem using backtracking.
2. Solve the Sudoku puzzle using backtracking.
3. Solve the subset sum problem using backtracking.
4. Implement the rat in a maze problem using backtracking.
5. Solve the combination sum problem using backtracking.

---

## 9. Logical Algorithms

### Basic:
1. Find the missing number in a given range from `1` to `n`.
2. Write a program to check if a given number is a power of two.
3. Write a program to generate all prime numbers up to a given limit.
4. Implement a program to compute the greatest common divisor (GCD) of two numbers.
5. Implement a program to compute the least common multiple (LCM) of two numbers.

### Intermediate:
1. Write a program to find the prime factorization of a number.
2. Write a program to compute the nth Fibonacci number using dynamic programming.
3. Write a program to find all divisors of a number.
4. Implement the Sieve of Eratosthenes algorithm to find all primes up to a given number.
5. Implement an algorithm to calculate the factorial of a number.

### Advanced:
1. Implement the Euclidean algorithm to find the greatest common divisor (GCD).
2. Solve the problem of finding the largest prime factor of a number.
3. Solve the problem of finding the shortest path between two nodes in a graph using Dijkstra’s algorithm.
4. Implement a program to count the number of set bits in a number.
5. Implement a program to check if a number is a palindrome.
